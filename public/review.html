<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Review</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    .wrap { max-width: 1000px; margin: 0 auto; padding: 16px; }
    h1 { font-size: 18px; margin: 0 0 12px; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin:12px 0; }
    input, select, button { font-size:14px; padding:6px 10px; }
    table { width:100%; border-collapse:collapse; font-size:14px; }
    th, td { padding:8px; border-bottom:1px solid #e5e7eb; text-align:left; vertical-align:top; }
    .meta { color:#6b7280; font-size:12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Review Bundle</h1>

    <div class="row">
      <div id="bundleTitle" style="font-weight:600;">—</div>
      <div class="meta" id="bundleMeta">Start: — • Timezone: —</div>
    </div>

    <div class="row">
      <label for="mode">Push mode:</label>
      <select id="mode">
        <option value="append" selected>append</option>
        <option value="replace">replace</option>
      </select>

      <label for="listTitle">List title:</label>
      <input id="listTitle" type="text" placeholder="Plan: —" />

      <label for="userEmail">User:</label>
      <input id="userEmail" type="email" placeholder="user@example.com" />

      <button id="btnPush">Push</button>
    </div>

    <table>
      <thead>
        <tr>
          <th style="width:22%;">Date (YYYY-MM-DD)</th>
          <th style="width:12%;">Time (HH:MM)</th>
          <th style="width:12%;">Duration</th>
          <th>Title</th>
          <th style="width:28%;">Notes</th>
        </tr>
      </thead>
      <tbody id="tbody">
        <tr><td colspan="5">Loading…</td></tr>
      </tbody>
    </table>
  </div>

  <script>
    // Defaults per your rules
    const plannerEmail = "bartpaden@gmail.com";
    const defaultUserEmail = "bart@midwesternbuilt.com";
    const defaultTimezone = "America/Chicago";

    const q = new URLSearchParams(window.location.search);
    const inboxId = q.get('inboxId') || "";

    const els = {
      title: document.getElementById('bundleTitle'),
      meta: document.getElementById('bundleMeta'),
      tbody: document.getElementById('tbody'),
      mode: document.getElementById('mode'),
      listTitle: document.getElementById('listTitle'),
      userEmail: document.getElementById('userEmail'),
      btnPush: document.getElementById('btnPush'),
    };

    // --- Helper: date math done locally, no offset display ---
    function pad(n){ return String(n).padStart(2,'0'); }
    function addDays(yyyyMmDd, offsetDays){
      const [y,m,d] = (yyyyMmDd||"").split('-').map(Number);
      if (!y || !m || !d) return "";
      const dt = new Date(y, m-1, d);
      dt.setDate(dt.getDate() + Number(offsetDays||0));
      return `${dt.getFullYear()}-${pad(dt.getMonth()+1)}-${pad(dt.getDate())}`;
    }
    function hhmm(t){
      if (t === null || t === undefined || t === "") return "";
      // Normalize "HH:MM:SS" → "HH:MM"
      return String(t).slice(0,5);
    }

    // Current bundle cache (for push)
    let bundleCache = {
      title: "",
      startDate: "",
      timezone: defaultTimezone,
      tasks: [],
      userEmail: ""
    };

    function normalizeBundleShape(body) {
      // API can return { bundle: {...} } or a flat object
      const b = body?.bundle || body || {};
      return {
        title: b.title || "",
        startDate: b.start_date || b.startDate || "",
        timezone: b.timezone || defaultTimezone,
        userEmail: b.userEmail || b.suggested_user || "",
        tasks: b.tasks || body?.tasks || []
      };
    }

    function normalizeTasks(tasks, startDate){
      return (tasks || []).map(t => {
        const date = t.date || (t.dayOffset != null ? addDays(startDate, t.dayOffset) : "");
        return {
          title: t.title || "",
          date,
          time: hhmm(t.time),
          durationMins: (t.durationMins != null) ? t.durationMins : null,
          notes: t.notes || ""
        };
      });
    }

    function renderTasks(rows){
      if (!rows.length){
        els.tbody.innerHTML = `<tr><td colspan="5">No tasks.</td></tr>`;
        return;
      }
      els.tbody.innerHTML = rows.map(r => `
        <tr>
          <td>${r.date}</td>
          <td>${r.time || ""}</td>
          <td>${r.durationMins ? r.durationMins + " mins" : ""}</td>
          <td>${r.title}</td>
          <td>${r.notes}</td>
        </tr>
      `).join('');
    }

    async function loadBundle(){
      if (!inboxId) {
        els.tbody.innerHTML = `<tr><td colspan="5">Missing inboxId.</td></tr>`;
        return;
      }
      try {
        const url = `/api/inbox/get?inboxId=${encodeURIComponent(inboxId)}&plannerEmail=${encodeURIComponent(plannerEmail)}`;
        const r = await fetch(url);
        const body = await r.json().catch(()=> ({}));

        const b = normalizeBundleShape(body);
        bundleCache.title = b.title;
        bundleCache.startDate = b.startDate;
        bundleCache.timezone = b.timezone || defaultTimezone;
        bundleCache.userEmail = b.userEmail || defaultUserEmail;
        bundleCache.tasks = normalizeTasks(b.tasks, b.startDate);

        els.title.textContent = b.title || "—";
        els.meta.textContent = `Start: ${b.startDate || "—"} • Timezone: ${bundleCache.timezone}`;
        els.listTitle.placeholder = `Plan: ${b.title || ""}`;
        els.userEmail.value = bundleCache.userEmail;

        renderTasks(bundleCache.tasks);
      } catch (e) {
        els.tbody.innerHTML = `<tr><td colspan="5">Failed to load.</td></tr>`;
      }
    }

    async function pushBundle(){
      // Read the table to guarantee only absolute dates go out
      const rows = Array.from(els.tbody.querySelectorAll('tr')).map(tr => {
        const tds = tr.querySelectorAll('td');
        if (tds.length < 5) return null;
        const date = tds[0].textContent.trim();
        const time = tds[1].textContent.trim() || null;
        const durTxt = tds[2].textContent.trim();
        const title = tds[3].textContent.trim();
        const notes = tds[4].textContent.trim();
        const durationMins = durTxt ? parseInt(durTxt.replace(/\D+/g,''),10) : null;
        return { title, date, time, durationMins, notes };
      }).filter(Boolean);

      if (rows.some(r => !r.date)) {
        // Quietly abort if any date missing (no debug surface)
        return;
      }

      const payload = {
        plannerEmail,
        userEmail: (els.userEmail.value || defaultUserEmail).trim(),
        listTitle: (els.listTitle.value || els.listTitle.placeholder || `Plan: ${bundleCache.title}`).trim(),
        timezone: bundleCache.timezone || defaultTimezone,
        startDate: bundleCache.startDate,
        mode: els.mode.value === "replace" ? "replace" : "append",
        items: rows.map(r => ({
          title: r.title,
          date: r.date,
          time: r.time,                 // may be null
          durationMins: r.durationMins, // may be null
          notes: r.notes || undefined
        }))
      };

      try {
        await fetch('/api/push', {
          method: 'POST',
          headers: { 'Content-Type':'application/json' },
          body: JSON.stringify(payload)
        });
        // No debug/status surface shown per your instruction
      } catch (e) {
        // Silent failure per your “no status” preference
      }
    }

    // Events
    els.btnPush.addEventListener('click', pushBundle);

    // Init
    loadBundle();
  </script>
</body>
</html>
